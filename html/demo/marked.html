<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MarkDown Preview</title>
    <link rel="stylesheet" href="marked.css">
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/default.min.css">
    <style>
        html, body { /* reset */
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            scroll-behavior: smooth;
        }

        .sr-only { /* tip text */
            display: none;
        }

        .wrapper { /* 占满全屏 flex 3 column 左输入框 中宽度调整 右预览*/
            width: 100%;
            height: 100%;
            display: flex;
        }

        .edit {
            width: calc(50% - 5px); /* 2px = divide border */
        }

        .divide {
            width: 5px;
            border: 1px dotted #ccc;
            cursor: col-resize;
        }

        .divide:hover {
            border: 1px dashed #aaa;
        }

        .preview {
            width: 50%;
        }

        textarea#editor {
            box-sizing: border-box;
            width: 99%;
            height: 98%;
            margin: 1% 0 1% 1%;
            padding: 1%;
            resize: none;
            border-color: #ccc;
        }

        main#preview {
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            padding: 1%;
            overflow-y: auto;
            word-break: break-word;
        }
    </style>
</head>
<body>
<div class="wrapper">
    <section class="item edit">
        <label for="editor" class="sr-only">输入区域</label>
        <textarea name="editor" id="editor">### 需求来源
有些网站的广告元素很容易找，想直接把它 `display:none` 掉，或者把某些带背景图像的元素隐藏或更换背景图片。
然后找到了一个 Chrome 插件 [Stylus](https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne/related "Stylus") 也能用但感觉没有必要单独装一个插件，还很复杂的样子。
想着油猴脚本应该有很多类似的，结果搜了一下都是针对特定网站的（比如百度/B站/知乎美化），于是就自己写了这个油猴插件。

![效果图](https://youthlin.com/wp-content/uploads/2021/01/inject-css-效果图.png "效果图")

<!--more-->

### 使用方式
需要先安装用户脚本管理器 [Tampermonkey](https://www.tampermonkey.net/index.php) （即俗称的油猴插件），然后点击 [这里](https://github.com/youthlin/examples/raw/master/html/demo/tampermonkey/inject-css.user.js "安装脚本") 安装脚本，点击 [这里](https://github.com/youthlin/examples/blob/master/html/demo/tampermonkey/inject-css.user.js "预览脚本") 预览脚本（见 [Gist 地址](https://gist.github.com/youthlin/c4c08ffe4273ca7ebbf759289cef9964) ）。
油猴脚本开发可以参考之前的文章：[如何编写一个油猴脚本](https://youthlin.com/?p=1698)

### 实现原理
一个 URL 正则表达式对应一条 CSS 规则，将所有规则保存起来（油猴提供了两个 API `GM_getValue` / `GM_setValue` 供存取设置内容）。
然后在每个页面加载后，遍历所有规则，找到所有对本页适用的规则，直接注入到页面中。
本着一个脚本做一件事的原则，这个脚本只提供注入 CSS 功能，而不提供注入 JS 的功能。

### 局限性
在浏览 GNU 的 [ftp 站点](https://ftp.gnu.org/gnu/gettext/ "gnu ftp gettext 的站点") 时发现规则没有生效。然后认识了一个 HTTP 响应头 `Content-Security-Policy` 。
该站点的此响应头是这样设置的：
```
Content-Security-Policy: default-src 'self'; img-src data: 'self' https://static.fsf.org https://gnu.org; object-src 'none'; frame-ancestors 'none'; child-src 'self' https://static.gnu.org https://static1p.gnu.org https://static1p.fsf.org;script-src 'unsafe-eval' 'self'
```
报错信息如下：
```
Refused to apply inline style because it violates the following Content Security Policy directive: "default-src 'self'". Either the 'unsafe-inline' keyword, a hash ('sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU='), or a nonce ('nonce-...') is required to enable inline execution. Note also that 'style-src' was not explicitly set, so 'default-src' is used as a fallback.
```
这个 header 对应的值是多个分号分隔的部分，指定了页面支持哪些来源的资源。
第一个 `default-src` 指定默认的资源来源是 `self` 即当前域名。
根据报错信息提示，浏览器拒绝应用注入的样式，因为内容安全策略设置的 `default-src` 指定了只接受同域名的样式，而没有接受行内样式 `unsafe-inline` ，也没有指定可执行的样式的 hash, nonce 值。
因为没有指定 `style-src` 所以使用的是 `default-src` 规则。
更多内容安全策略的相关知识，大家可以参考 MDN 文章 [内容安全策略( CSP )](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP) 、[Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy) ，以及阮一峰的博文 [Content Security Policy 入门教程](https://www.ruanyifeng.com/blog/2016/09/csp.html) 。

### 分享一些规则
找到了广告元素后，可以直接使用 `display: none` 将其隐藏，另外插件还注入了一个水印层， class 是 `.inject-watermark` ，也可以用来添加自定义水印～
```css
body > div:empty {
  /* body 的空的子元素去除背景 */
  background: transparent !important;
}

.inject-watermark {
  /* 插件注入的元素，覆盖整个页面。可以添加自定义水印 */
  background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext x='50%25' y='50%25' font-size='14' fill='%23a2a9b6' fill-opacity='0.5' font-family='system-ui, sans-serif' text-anchor='middle' dominant-baseline='middle' transform='rotate(-45 50 50)'%3Eyouthlin.com%3C/text%3E%3C/svg%3E")
}

```

`svg` 可以作为背景水印，如何将文本写在 svg 上，可以参考菜鸟教程 [SVG &lt;text>](https://www.runoob.com/svg/svg-text.html) 。从教程的 *尝试一下* 按钮可以进入 svg 在线编辑器。
另外再推荐张鑫旭的几篇相关文章：
[如何让文字作为CSS背景图片显示？](https://www.zhangxinxu.com/wordpress/?p=9615) ；
如果想要将文字倾斜，还可以看下 svg 中如何旋转
[理解SVG transform坐标变换](https://www.zhangxinxu.com/wordpress/?p=4965) ；
最后为了把 svg 放在背景上，通常可以使用 base64 编码 svg 后放在 `background-image` 的 url 中，
不过，还有另一种可读性更好的方式
[学习了，CSS中内联SVG图片有比Base64更好的形式](https://www.zhangxinxu.com/wordpress/?p=7957) 。
</textarea>
    </section>
    <div class="item divide"></div>
    <section class="item preview">
        <main id="preview"></main>
    </section>
</div>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script>
<script>
    const ready = function (fn) {
        if (document.readyState !== 'loading') {
            fn();
        } else {
            document.addEventListener('DOMContentLoaded', fn);
        }
    };

    let links = [] // 文中所有链接 []{text, href}

    function compile(editor, preview) {// 转换 editor markdown 到 preview html
        links = []
        const tokens = marked.lexer(editor.value)
        // console.log(tokens)
        let content = marked.parser(tokens)
        const length = links.length
        if (length > 0) {// 有链接，添加参考资料在底部
            content += '<br><h6>参考资料</h6><section>'
            for (let i = 0; i < length; i++) {
                content += `<span class="footnote"><span class="ft-num">[${i + 1}]</span>
<span class="ft-content"><span class="ft-text">${links[i].text}</span>: <em class="ft-link">${links[i].href}</em></span></span>`
            }
            content += "</section><p>* 微信不支持外链，可点击 <em>阅读原文</em> 获得更佳体验</p>"
        }
        preview.innerHTML = content
    }

    ready(function () {
        marked.setOptions({
            // https://marked.js.org/using_advanced#options
            gfm: true,			// GitHub 风格
            tables: true,		// 支持表格
            breaks: true,		// 回车换成 br
            headerIds: true,    // 标题添加 id
            // highlight: function (code, lang, callback) {
            //     const result = hljs.highlightAuto(code).value
            //     const line = result.split('\n')
            //     return result
            // },
        });
        const renderer = {
            // https://marked.js.org/using_pro#renderer
            heading(text, level, raw, slugger) {
                // raw: '
                // text: &#39;
                // encodeURI 会保留 &
                const escapedText = encodeURIComponent(slugger.slug(raw.toLowerCase()))
                return `<h${level}><a name="${escapedText}" class="anchor" href="#${escapedText}"></a><span class="heading-text">${text}</span></h${level}>`;
            },
            code(code, lang, escaped) {// 代码高亮
                const result = hljs.highlightAuto(code).value
                const item = result.split('\n').map(line => `<li class="code-line">${line}</li>`).join('')
                return `<pre><code><ol class="code">${item}</ol></code></pre>`
            },
            link(href, title, text) { // 链接 a 标签
                links.push({text: title ? title : text, href: href});
                return `<span class="link"><a href="${href}" title="${title ? "" : title}">${text}</a><sup>[${links.length}]</sup></span>`;
            },
            image(href, title, text) { // 图片
                if (title) {
                    return `<figure><img src=${href} alt="${text}"><figcaption>${title}</figcaption></figure>`
                }
                return `<img src=${href} alt="${text}">`
            }
        }
        marked.use({renderer})

        const editor = document.querySelector('#editor');
        const preview = document.getElementById('preview');

        // 实时编译预览
        compile(editor, preview);
        editor.addEventListener('keyup', function () {
            compile(editor, preview);
        })

        // region 同步滚动
        // 这两个,标记当前滚动的是哪个元素
        let fromEditor = false;
        let fromPreview = false;

        function onScroll(e) {
            // console.log(e);
            const thisScroll = e.target;
            const thatScroll = thisScroll === editor ? preview : editor;
            if (thisScroll === editor) {
                fromEditor = true;// 当前滚动的是输入框
                if (fromPreview) {// 但是预览栏也在滚动，说明是预览的滚动导致输入框滚动，就不用再触发预览滚动了
                    // 所以重置两个标记
                    fromEditor = false;
                    fromPreview = false;
                    return;// 直接结束即可
                }
            } else {// 同理
                fromPreview = true;
                if (fromEditor) {
                    fromEditor = false;
                    fromPreview = false;
                    return;
                }
            }
            // https://zh.javascript.info/size-and-scroll
            // scrollTop 滚动出去在界面上方的高度(已经滚动的高度)
            // clientHeight 元素不包括边框含 padding 的高度
            // scrollHeight 元素内容的高度(包括已经滚动出去和还没显示的部分)
            // offsetHeight 元素包括边框的高度

            // // 错误的百分比: 可能导致 editor 在顶部，preview 却滚动了一点点
            // const percent = (thisScroll.scrollTop + thisScroll.clientHeight) / thisScroll.scrollHeight;
            // thatScroll.scrollTop = thatScroll.scrollHeight * percent - thatScroll.clientHeight;

            const percent = thisScroll.scrollTop / (thisScroll.scrollHeight - thisScroll.offsetHeight);
            thatScroll.scrollTop = percent * (thatScroll.scrollHeight - thatScroll.offsetHeight);
        }

        editor.addEventListener('scroll', onScroll);
        preview.addEventListener('scroll', onScroll);
        // endregion 同步滚动

    });
</script>
</body>
</html>
